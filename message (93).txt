#include <vector>
#include <numeric> // for accumulate
#include <iostream> // for printing results
#include <exception> // for exception handling

std::vector<std::vector<std::vector<double>>> calc_brutto_ring(std::vector<double> data_input,
    std::vector<double> insurance, std::vector<double> reas_input, double kat_val, int ilosc_ubezpieczycieli,
    int insurancer, double wielkosc_pozar_kwota)
{
    std::vector<std::vector<std::vector<double>>> out_final(9);
    std::vector<std::vector<double>> out_brutto(ilosc_ubezpieczycieli);
    std::vector<std::vector<double>> out_kat_brutto(ilosc_ubezpieczycieli);
    std::vector<std::vector<double>> ind_brutto(ilosc_ubezpieczycieli);
    std::vector<std::vector<double>> ind_kat_brutto(ilosc_ubezpieczycieli);
    std::vector<std::vector<double>> out_sum_brutto(ilosc_ubezpieczycieli);
    std::vector<std::vector<double>> out_sum_kat_brutto(ilosc_ubezpieczycieli);
    std::vector<std::vector<double>> out_reas_standard(ilosc_ubezpieczycieli);
    std::vector<std::vector<double>> out_reas_kat(ilosc_ubezpieczycieli);
    std::vector<double> wielkosc_pozar_kwota_output(2);

    int ind_next = 0;

    try {
        for (auto it = std::begin(insurance); it != std::end(insurance); ++it)
        {
            int insurer_index = static_cast<int>(*it);
            if (insurer_index >= 0 && insurer_index < ilosc_ubezpieczycieli && ind_next < data_input.size() && ind_next < reas_input.size()) {
                out_brutto[insurer_index].push_back(data_input[ind_next]);
                ind_brutto[insurer_index].push_back(ind_next);
                out_reas_standard[insurer_index].push_back(reas_input[ind_next]);
            }
            else {
                std::cerr << "Błąd: Indeks ubezpieczyciela poza zakresem lub dane wejściowe są nieprawidłowe.\n";
            }
            ind_next += 1;
        }

        for (int i = 0; i < ilosc_ubezpieczycieli; i++)
        {
            if (!out_brutto[i].empty()) {
                double sum_brutto = std::accumulate(out_brutto[i].begin(), out_brutto[i].end(), 0.0);

                // Jeśli obecny ubezpieczyciel to insurancer, dodaj wielkosc_pozar_kwota do sumy
                if (i == insurancer)
                {
                    sum_brutto += wielkosc_pozar_kwota;
                }

                out_sum_brutto[i].push_back(sum_brutto);

                // Sprawdzenie, czy suma wartości jest większa niż kat_val
                if (sum_brutto > kat_val)
                {
                    out_kat_brutto[i] = out_brutto[i];  // Przypisujemy całą listę wartości do out_kat_brutto
                    ind_kat_brutto[i] = ind_brutto[i];  // Przypisujemy indeksy dla wartości katastroficznych
                    out_reas_kat[i] = out_reas_standard[i];  // Przypisujemy odpowiednie wartości reasekuracji
                    out_sum_kat_brutto[i].push_back(sum_brutto);  // Dodajemy sumę wartości katastroficznych
                }
            }
            else {
                std::cerr << "Ostrzeżenie: Brak danych do obliczeń dla ubezpieczyciela " << i << ".\n";
            }
        }

        // Określenie wartości wielkosc_pozar_kwota_output na podstawie sumy dla insurancer
        double suma_insurancer = 0.0;
        if (insurancer >= 0 && insurancer < out_sum_brutto.size() && !out_sum_brutto[insurancer].empty()) {
            suma_insurancer = out_sum_brutto[insurancer][0];
        }
        else {
            std::cerr << "Błąd: Nieprawidłowy dostęp do out_sum_brutto dla insurancer: " << insurancer << "\n";
        }

        if (suma_insurancer > kat_val)
        {
            wielkosc_pozar_kwota_output[0] = insurancer;
            wielkosc_pozar_kwota_output[1] = wielkosc_pozar_kwota;
        }
        else
        {
            wielkosc_pozar_kwota_output[0] = insurancer;
            wielkosc_pozar_kwota_output[1] = 0;
        }

        out_final[0] = out_brutto;
        out_final[1] = out_kat_brutto;
        out_final[2] = out_sum_brutto;
        out_final[3] = out_sum_kat_brutto;
        out_final[4] = ind_brutto;
        out_final[5] = ind_kat_brutto;
        out_final[6] = out_reas_standard;
        out_final[7] = out_reas_kat;
        out_final[8] = { wielkosc_pozar_kwota_output };
    }
    catch (const std::exception& e) {
        std::cerr << "Wystąpił wyjątek: " << e.what() << "\n";
    }
    catch (...) {
        std::cerr << "Wystąpił nieznany błąd.\n";
    }

    return (out_final);
}




int main() {
    // Przykładowe dane wejściowe do przetestowania funkcji
    std::vector<double> data_input = { 50.0, 150.0, 70.0, 20.0, 50.0, 10.0, 30.0, 10.0, 20.0, 5 };
    std::vector<double> insurance = { 0, 1, 2, 1, 0, 2, 1, 0, 2, 1 };
    std::vector<double> reas_input = { 1000.0, 5000.0, 20000.0, 5000.0, 200000.0, 500000.0, 300.0, 15000.0, 200000.0, 40000.0 };
    double kat_val = 1000000.0;  // Duża wartość graniczna, aby przetestować zachowanie przy przekraczaniu wartości katastroficznej
    int ilosc_ubezpieczycieli = 3;  // Liczba ubezpieczycieli
    int insurancer = 1;  // Ubezpieczyciel dla którego dodajemy wielkosc_pozar_kwota
    double wielkosc_pozar_kwota =100;  // Duża kwota do przetestowania sumowania wartości katastroficznych

    // Wywołanie funkcji calc_brutto_ring
    std::vector<std::vector<std::vector<double>>> result = calc_brutto_ring(data_input, insurance, reas_input, kat_val, ilosc_ubezpieczycieli, insurancer, wielkosc_pozar_kwota);

    // Wypisanie wyników
    for (int i = 0; i < result.size(); ++i) {
        std::cout << "Result vector " << i << ":\n";
        for (int j = 0; j < result[i].size(); ++j) {
            std::cout << "  Insurer " << j << ": ";
            for (double val : result[i][j]) {
                std::cout << val << " ";
            }
            std::cout << "\n";
        }
    }

    return 0;
}
