import numpy as np
import pandas as pd
import multiprocessing as mp
from tqdm import tqdm

# Globalne ustawienie seed w każdym procesie
def init_worker(seed):
    np.random.seed(seed)

# 1. Generator PRNG z seed
class PCG64Generator:
    def __init__(self, seed=None):
        self.rng = np.random.default_rng(seed)

    def normal(self, mu=0, sigma=1, size=1):
        return self.rng.normal(loc=mu, scale=sigma, size=size)

    def lognormal(self, mean=0, sigma=1, size=1):
        return self.rng.lognormal(mean=mean, sigma=sigma, size=size)

    def chi_squared(self, df, size=1):
        return self.rng.chisquare(df=df, size=size)

# 2. Funkcja do symulacji stochastycznych parametrów
def random_stochastic_parameters(sigma_j, dev, sd, e_values, mm, nSimPart, seed):
    rng = PCG64Generator(seed)
    nDev = len(dev)
    mu_part = np.zeros((nSimPart, nDev))
    sig_part = np.zeros((nSimPart, nDev))

    for j in range(nDev):
        mu_part[:, j] = rng.normal(mu=dev[j], sigma=sd[j], size=nSimPart)
        df = max(1, mm - j)
        chi_list = rng.chi_squared(df, size=nSimPart)
        sig_part[:, j] = (chi_list * sigma_j[j] ** 2) / e_values[j]
    
    return mu_part, sig_part

# 3. Funkcja równoległa do przetwarzania wierszy
def process_row(local_index, mu_mat_global, sigma_mat_global, data_paid_global, e_values, Ultimate_Param_ResRisk_global, seed):
    rng = PCG64Generator(seed + local_index)
    m_i = mu_mat_global[local_index, :]
    sigma_i = sigma_mat_global[local_index, :]
    data_paid_copy = np.copy(data_paid_global)
    mm, n_cols = data_paid_copy.shape
    n_dev = len(m_i)
    
    for j in range(len(m_i)):
        max_ind_row = max(1, mm - j)
        for i in range(max_ind_row - 1, mm):
            VAR_i_j = sigma_i[j]  # Już podzielone przez e_i w poprzednim kroku
            
            if m_i[j] >= 0:
                lmean = np.log((m_i[j] ** 2) / np.sqrt(m_i[j] ** 2 + VAR_i_j))
                lstdev = np.sqrt(np.log(1 + VAR_i_j / m_i[j] ** 2))
                Stochastic_LR_i_j = rng.lognormal(lmean, lstdev, size=1)[0]
                data_paid_copy[i, j+1] = e_values[j] * Stochastic_LR_i_j + data_paid_copy[i, j]
            else:
                adj_mu = m_i[j] + (data_paid_copy[i, j] / e_values[j])
                lmean = np.log((adj_mu ** 2) / np.sqrt(adj_mu ** 2 + VAR_i_j))
                lstdev = np.sqrt(np.log(1 + VAR_i_j / (adj_mu ** 2)))
                Stochastic_LR_i_j = rng.lognormal(lmean, lstdev, size=1)[0]
                data_paid_copy[i, j+1] = e_values[j] * (Stochastic_LR_i_j - data_paid_copy[i, j] / e_values[j]) + data_paid_copy[i, j]
    
    u_i = data_paid_copy[:, -1]
    return np.sum(u_i) - Ultimate_Param_ResRisk_global
