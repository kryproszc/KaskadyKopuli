#include <pqxx/pqxx>
#include <future>
#include <random>
#include <iostream>
#include <filesystem>
#include <vector>
#include <fstream>
#include <string>
#include <utility>
#include <map>
#include <ostream>
#include <set>
#include <thread>
#include <chrono>
#include <tuple>
#include <nlohmann/json.hpp> // Biblioteka JSON

#include "csvstream.hpp"

namespace fs = std::filesystem;
using json = nlohmann::json;

fs::path path = "/mnt/c/Users/szczkr/test";

int numberOfDataPointsPerRegion = 100; // Liczba adresów z każdego województwa
size_t numThreads = 32;

struct FileInfo
{
    fs::path path;
    size_t startIndex;
    size_t lineCount;
};

namespace Color
{
    enum Code
    {
        FG_RED = 31,
        FG_GREEN = 32,
        FG_YELLOW = 33,
        FG_BLUE = 34,
        FG_MAGENTA = 35,
        FG_CYAN = 36,
        FG_WHITE = 37,
        FG_DEFAULT = 39,
        BG_RED = 41,
        BG_GREEN = 42,
        BG_YELLOW = 43,
        BG_BLUE = 44,
        BG_MAGENTA = 45,
        BG_CYAN = 46,
        BG_WHITE = 47,
        BG_DEFAULT = 49
    };
    class Modifier
    {
        Code code;

    public:
        Modifier(Code pCode) : code(pCode) {}
        friend std::ostream &
        operator<<(std::ostream &os, const Modifier &mod)
        {
            return os << "\033[" << mod.code << "m";
        }
    };
}

Color::Modifier red(Color::FG_RED);
Color::Modifier def(Color::FG_DEFAULT);
Color::Modifier green(Color::FG_GREEN);
Color::Modifier blue(Color::FG_BLUE);
Color::Modifier yellow(Color::FG_YELLOW);
Color::Modifier magneta(Color::FG_MAGENTA);
Color::Modifier cyan(Color::BG_CYAN);
Color::Modifier deff(Color::BG_DEFAULT);

void logProgress(const std::string &message)
{
    std::cout << red << "[INFO] " << def << message << std::endl;
}

std::string removeLastChar(const std::string &line)
{
    if (!line.empty())
    {
        return line.substr(0, line.size() - 1);
    }
    return line;
}

std::vector<fs::path> getCsvFiles(const fs::path &path)
{
    std::vector<fs::path> csvFiles;
    for (const auto &entry : fs::recursive_directory_iterator(path))
    {
        if (entry.is_regular_file() && entry.path().extension() == ".csv" &&
            entry.path().stem().string().find("_final") == std::string::npos)
        {
            csvFiles.push_back(entry.path());
        }
    }
    return csvFiles;
}

struct Address
{
    std::string lp;
    std::string dataPoczatku;
    std::string dataKonca;
    std::string sumaUbezpieczenia;
    std::string odnowienia;
    std::string ulica;
    std::string kodPocztowy;
    std::string miasto;
    std::string wojewodztwo;
    std::string kraj;
    std::string reasekuracjaO;
    std::string reasekuracjaF;
    std::string szerokosc;
    std::string dlugosc;
    std::string flaga1;
    std::string flaga2;
    std::string nrwoj;

    std::string toString() const
    {
        return lp + ";" + dataPoczatku + ";" + dataKonca + ";" + sumaUbezpieczenia + ";" +
               odnowienia + ";" + ulica + ";" + kodPocztowy + ";" + miasto + ";" +
               wojewodztwo + ";" + kraj + ";" + reasekuracjaO + ";" + reasekuracjaF + ";" +
               szerokosc + ";" + dlugosc + ";" + flaga1 + ";" + flaga2 + ";" + nrwoj;
    }
};

std::vector<Address> toProcess;
std::vector<Address> generatedData;

std::vector<int> findDuplicateCoordinates(const std::vector<Address> &toProcess)
{
    std::map<std::pair<std::string, std::string>, std::set<int>> coordMap;
    std::vector<int> duplicateIndices;

    for (int i = 0; i < toProcess.size(); ++i)
    {
        const auto &address = toProcess[i];
        if ((address.szerokosc == "brak danych" || address.flaga1 == "0" || address.flaga1 == "4" || address.flaga1 == "5" || address.flaga1 == "6") ||
            ((address.flaga1 == "1" || address.flaga1 == "2" || address.flaga1 == "3") && address.flaga2 != "0"))
        {
            std::pair<std::string, std::string> coord(address.szerokosc, address.dlugosc);
            coordMap[coord].insert(i);
        }
    }

    for (const auto &entry : coordMap)
    {
        if (entry.second.size() > 1)
        {
            duplicateIndices.insert(duplicateIndices.end(), entry.second.begin(), entry.second.end());
        }
        else if (entry.second.size() == 1)
        {
            int firstIndex = *entry.second.begin();
            if (toProcess[firstIndex].szerokosc == "brak danych")
                duplicateIndices.insert(duplicateIndices.end(), entry.second.begin(), entry.second.end());
        }
    }

    return duplicateIndices;
}

void add(const Address &pos)
{
    toProcess.push_back(pos);
}

void addGeneratedData(const Address &pos)
{
    generatedData.push_back(pos);
}

void processChunk(const std::vector<Address> &generatedData, const std::vector<Address> &toProcess,
                  std::vector<Address> &localResult, size_t start, size_t end)
{
    for (size_t i = start; i < end; ++i)
    {
        bool shouldErase = false;
        for (const auto &process : toProcess)
        {
            if (generatedData[i].szerokosc == process.szerokosc && generatedData[i].dlugosc == process.dlugosc)
            {
                shouldErase = true;
                break;
            }
        }
        if (!shouldErase)
        {
            localResult.push_back(generatedData[i]);
        }
    }
}

void removeMatchingCoordinates(std::vector<Address> &generatedData, const std::vector<Address> &toProcess)
{
    size_t chunkSize = generatedData.size() / numThreads;
    std::vector<std::thread> threads;
    std::vector<std::vector<Address>> results(numThreads);

    for (size_t i = 0; i < numThreads; ++i)
    {
        size_t start = i * chunkSize;
        size_t end = (i == numThreads - 1) ? generatedData.size() : start + chunkSize;

        threads.emplace_back(processChunk, std::cref(generatedData), std::cref(toProcess),
                             std::ref(results[i]), start, end);
    }

    for (auto &thread : threads)
    {
        thread.join();
    }

    std::vector<Address> finalResult;
    for (const auto &localResult : results)
    {
        finalResult.insert(finalResult.end(), localResult.begin(), localResult.end());
    }

    generatedData = finalResult;

    std::sort(generatedData.begin(), generatedData.end(),
              [](const Address &a, const Address &b)
              {
                  return std::tie(a.szerokosc, a.dlugosc) < std::tie(b.szerokosc, b.dlugosc);
              });

    generatedData.erase(
        std::unique(generatedData.begin(), generatedData.end(),
                    [](const Address &a, const Address &b)
                    {
                        return a.szerokosc == b.szerokosc && a.dlugosc == b.dlugosc;
                    }),
        generatedData.end());
}

void printAddresses(const std::vector<Address> &addresses, const std::string &title)
{
    std::cout << title << ":\n";
    for (const auto &address : addresses)
    {
        std::cout << address.lp << ","
                  << address.dataPoczatku << ","
                  << address.dataKonca << ","
                  << address.sumaUbezpieczenia << ","
                  << address.odnowienia << ","
                  << address.ulica << ","
                  << address.kodPocztowy << ","
                  << address.miasto << ","
                  << address.wojewodztwo << ","
                  << address.kraj << ","
                  << address.reasekuracjaO << ","
                  << address.reasekuracjaF << ","
                  << address.szerokosc << ","
                  << address.dlugosc << ","
                  << address.flaga1 << ","
                  << address.flaga2 << ","
                  << address.nrwoj
                  << "\n";
    }
    std::cout << std::endl;
}

int cur_el = 0;
const Address &randomElement(const std::vector<Address> &wektor)
{
    return wektor[cur_el++ % wektor.size()];
}

int num_generated_data = 0;
int max_num_generated_data = 0;
int max_files = 0;
int cur_fileProcessed = 0;
int linesToConcatenate = 0;
int concatenated_lines = 0;
int loadedLines = 0;
int max_duplicates = 0;
int num_dupl = 0;

std::vector<FileInfo> fileInfos;

void processData()
{
    auto start = std::chrono::high_resolution_clock::now();
    pqxx::connection c(
        "dbname=twoja_baza user=twoj_uzytkownik password=twoje_haslo host=localhost port=5432");
    pqxx::work txn(c);
    std::cout << "Połączono z bazą danych: " << c.dbname() << '\n';

    std::stringstream query;

    // Zapytanie SQL z użyciem geolokalizacji do przypisania województw
    query << "WITH wojewodztwa_geom AS (\n"
          << "  SELECT osm_id AS id, name AS nazwa, ST_Transform(way, 4326) AS geom\n"
          << "  FROM planet_osm_polygon\n"
          << "  WHERE boundary = 'administrative' AND admin_level = '4' AND name IS NOT NULL\n"
          << "),\n"
          << "ranked_data AS (\n"
          << "  SELECT\n"
          << "    p.postcode,\n"
          << "    p.address,\n"
          << "    ST_Y(p.centroid) AS lat,\n"
          << "    ST_X(p.centroid) AS lon,\n"
          << "    w.nazwa AS wojewodztwo,\n"
          << "    ROW_NUMBER() OVER (PARTITION BY w.nazwa ORDER BY RANDOM()) AS rn\n"
          << "  FROM placex p\n"
          << "  JOIN wojewodztwa_geom w ON\n"
          << "    ST_Contains(w.geom, p.centroid)\n"
          << "  WHERE\n"
          << "    p.address -> 'housenumber' IS NOT NULL AND\n"
          << "    p.address -> 'housenumber' != ''\n"
          << ")\n"
          << "SELECT *\n"
          << "FROM ranked_data\n"
          << "WHERE rn <= " << numberOfDataPointsPerRegion << ";\n";

    logProgress("Generowanie danych...");
    pqxx::result r = txn.exec(query);

    max_num_generated_data = r.size();

    for (const auto &row : r)
    {
        std::string city, street, postcode, housenumber, place, wojewodztwo;

        // Parsowanie pola 'address' jako JSON
        std::string address_field = row["address"].c_str();
        postcode = row["postcode"].c_str();
        wojewodztwo = row["wojewodztwo"].c_str();
        double lat = row["lat"].as<double>();
        double lon = row["lon"].as<double>();

        json address_json = json::parse(address_field);

        if (address_json.contains("city"))
            city = address_json["city"].get<std::string>();
        else if (address_json.contains("town"))
            city = address_json["town"].get<std::string>();
        else if (address_json.contains("village"))
            city = address_json["village"].get<std::string>();
        else if (address_json.contains("hamlet"))
            city = address_json["hamlet"].get<std::string>();

        if (address_json.contains("street"))
            street = address_json["street"].get<std::string>();

        if (address_json.contains("housenumber"))
            housenumber = address_json["housenumber"].get<std::string>();

        if (address_json.contains("place"))
            place = address_json["place"].get<std::string>();

        if (city.empty())
            city = place;

        addGeneratedData(Address{"", "", "", "", "", street + " " + housenumber, postcode, city, wojewodztwo,
                                 "", "", "", std::to_string(lat), std::to_string(lon), "", "", ""});

        num_generated_data++;
    }
    logProgress("Generowanie danych zakończone.");

    // Wczytywanie danych z plików CSV
    std::vector<fs::path> csvFiles = getCsvFiles(path);

    std::vector<std::string> allLines;
    std::string firstFileHeader;

    max_files = csvFiles.size();

    for (size_t fileIndex = 0; fileIndex < csvFiles.size(); ++fileIndex)
    {
        const auto &filePath = csvFiles[fileIndex];
        logProgress("Przetwarzanie pliku: " + filePath.string());

        cur_fileProcessed = fileIndex + 1;

        std::ifstream file(filePath);
        if (file.is_open())
        {
            FileInfo info;
            info.path = filePath;
            info.startIndex = allLines.size();
            info.lineCount = 0;

            std::string line;
            bool isFirstLine = true;
            while (std::getline(file, line))
            {
                if (fileIndex == 0)
                {

                    if (isFirstLine)
                    {
                        firstFileHeader = line;
                        isFirstLine = false;
                        allLines.push_back(line);
                    }
                    else
                    {
                        line = removeLastChar(line);

                        allLines.push_back(line);
                    }

                    info.lineCount++;
                }
                else
                {

                    if (isFirstLine)
                    {
                        isFirstLine = false;
                        continue;
                    }
                    line = removeLastChar(line);

                    allLines.push_back(line);
                    info.lineCount++;
                }
            }

            fileInfos.push_back(info);
            file.close();
        }
        else
        {
            std::cerr << "Nie można otworzyć pliku: " << filePath.string() << '\n';
        }
    }

    std::string csv_data;

    linesToConcatenate = allLines.size();
    for (const auto &line : allLines)
    {
        csv_data += line + "\n";

        concatenated_lines++;
    }

    std::istringstream iss(csv_data);

    csvstream csv(iss);
    std::vector<std::pair<std::string, std::string>> row;

    int l = 0;
    loadedLines = 1;
    while (csv >> row)
    {
        std::string lp = row[0].second;
        std::string datapoczatku = row[1].second;
        std::string datakonca = row[2].second;
        std::string sumaUbezpieczenia = row[3].second;
        std::string odnowienia = row[4].second;
        std::string ulica = row[5].second;
        std::string kodPocztowy = row[6].second;
        std::string miasto = row[7].second;
        std::string wojewodztwo = row[8].second;
        std::string kraj = row[9].second;
        std::string reasekuracjaO = row[10].second;
        std::string reasekuracjaF = row[11].second;
        std::string szerokosc = row[12].second;
        std::string dlugosc = row[13].second;
        std::string flaga1 = row[14].second;
        std::string flaga2 = row[15].second;
        std::string nr_woj = row[16].second;

        add(Address{lp, datapoczatku, datakonca, sumaUbezpieczenia, odnowienia, ulica, kodPocztowy, miasto, wojewodztwo,
                    kraj, reasekuracjaO, reasekuracjaF, szerokosc, dlugosc, flaga1, flaga2, nr_woj});

        loadedLines++;
    }

    logProgress("Usuwanie duplikatów współrzędnych...");
    removeMatchingCoordinates(generatedData, toProcess);
    logProgress("Duplikaty usunięte.");

    std::vector<int> duplicates = findDuplicateCoordinates(toProcess);

    max_duplicates = duplicates.size();
    for (int index : duplicates)
    {
        const Address element = randomElement(generatedData);

        toProcess[index].ulica = element.ulica;
        toProcess[index].miasto = element.miasto;
        toProcess[index].kodPocztowy = element.kodPocztowy;
        toProcess[index].wojewodztwo = element.wojewodztwo;
        toProcess[index].szerokosc = element.szerokosc;
        toProcess[index].dlugosc = element.dlugosc;
        toProcess[index].nrwoj = element.nrwoj;

        num_dupl++;
    }

    for (size_t fileIndex = 0; fileIndex < fileInfos.size(); ++fileIndex)
    {
        const auto &info = fileInfos[fileIndex];
        fs::path newFilePath = info.path;
        newFilePath.replace_filename(info.path.stem().string() + "_final" + info.path.extension().string());

        logProgress("Zapisywanie do pliku: " + newFilePath.string());
        std::ofstream outFile(newFilePath);
        if (outFile.is_open())
        {

            outFile << firstFileHeader << '\n';

            if (fileIndex == 0)
            {
                for (size_t i = info.startIndex; i < info.startIndex + info.lineCount - 1; ++i)
                {

                    outFile << toProcess[i].toString() << '\n';
                }
            }
            else
            {
                for (size_t i = info.startIndex - 1; i < info.startIndex - 1 + info.lineCount; ++i)
                {

                    outFile << toProcess[i].toString() << '\n';
                }
            }
            outFile.close();
            std::cout << "Zapisano do pliku: " << newFilePath.string() << '\n';
        }
        else
        {
            std::cerr << "Nie można zapisać do pliku: " << newFilePath.string() << '\n';
        }
    }

    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed = end - start;
    std::cout << red << "[INFO] " << green << "PROGRAM ZAKOŃCZYŁ SWOJE DZIAŁANIE. MOŻESZ Z NIEGO WYJŚĆ" << def << std::endl;
    std::cout << cyan << "Czas przetwarzania: " << elapsed.count() << " sekund." << deff << std::endl;
}

int main()
{
    bool exit = false;
    std::thread processingThread;

    while (!exit)
    {
        std::cout << "Wybierz opcję:\n";
        std::cout << "1. Rozpocznij przetwarzanie danych\n";
        std::cout << "2. Pokaż postęp prac\n";
        std::cout << "3. Pokaż na jakie segmenty został podzielony kontener\n";
        std::cout << "4. Wyjdź\n";
        int choice;
        std::cin >> choice;

        switch (choice)
        {
        case 1:
        {
            if (!processingThread.joinable())
            {
                processingThread = std::thread(processData);
            }
            else
            {
                std::cout << red << "Przetwarzanie danych jest już w toku.\n"
                          << def;
            }
            break;
        }
        case 2:
            std::cout << magneta << "[STATUS] Postęp w przetwarzaniu danych:" << def << std::endl;
            std::cout << yellow << "  - Liczba wygenerowanych danych: " << std::to_string(num_generated_data) << "/" << std::to_string(max_num_generated_data) << def << std::endl;
            std::cout << yellow << "  - Obecnie przetwarzany plik: " << std::to_string(cur_fileProcessed) << "/" << std::to_string(max_files) << def << std::endl;
            std::cout << yellow << "  - Budowanie wspólnego pliku: " << std::to_string(concatenated_lines) << "/" << std::to_string(linesToConcatenate) << def << std::endl;
            std::cout << yellow << "  - Wczytane rekordy z pliku: " << std::to_string(loadedLines) << "/" << std::to_string(linesToConcatenate) << def << std::endl;
            std::cout << yellow << "  - Liczba przetworzonych duplikatów: " << std::to_string(num_dupl) << "/" << std::to_string(max_duplicates) << def << std::endl;
            break;
        case 3:
            for (const auto &info : fileInfos)
            {
                std::cout << blue << "Plik: " << info.path.string()
                          << ", Start Index: " << info.startIndex
                          << ", Line Count: " << info.lineCount << '\n'
                          << def;
            }
            break;
        case 4:
            exit = true;
            if (processingThread.joinable())
            {
                processingThread.join();
            }
            break;
        default:
            std::cout << "Nieprawidłowa opcja, spróbuj ponownie.\n";
            break;
        }
    }

    return 0;
}
